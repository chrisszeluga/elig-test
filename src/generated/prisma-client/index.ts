// Code generated by Prisma (prisma@1.34.7). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  clinician: (where?: ClinicianWhereInput) => Promise<boolean>;
  groupStatus: (where?: GroupStatusWhereInput) => Promise<boolean>;
  individualStatus: (where?: IndividualStatusWhereInput) => Promise<boolean>;
  practice: (where?: PracticeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  clinician: (where: ClinicianWhereUniqueInput) => ClinicianNullablePromise;
  clinicians: (args?: {
    where?: ClinicianWhereInput;
    orderBy?: ClinicianOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Clinician>;
  cliniciansConnection: (args?: {
    where?: ClinicianWhereInput;
    orderBy?: ClinicianOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClinicianConnectionPromise;
  groupStatus: (
    where: GroupStatusWhereUniqueInput
  ) => GroupStatusNullablePromise;
  groupStatuses: (args?: {
    where?: GroupStatusWhereInput;
    orderBy?: GroupStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GroupStatus>;
  groupStatusesConnection: (args?: {
    where?: GroupStatusWhereInput;
    orderBy?: GroupStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupStatusConnectionPromise;
  individualStatus: (
    where: IndividualStatusWhereUniqueInput
  ) => IndividualStatusNullablePromise;
  individualStatuses: (args?: {
    where?: IndividualStatusWhereInput;
    orderBy?: IndividualStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<IndividualStatus>;
  individualStatusesConnection: (args?: {
    where?: IndividualStatusWhereInput;
    orderBy?: IndividualStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IndividualStatusConnectionPromise;
  practice: (where: PracticeWhereUniqueInput) => PracticeNullablePromise;
  practices: (args?: {
    where?: PracticeWhereInput;
    orderBy?: PracticeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Practice>;
  practicesConnection: (args?: {
    where?: PracticeWhereInput;
    orderBy?: PracticeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PracticeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createClinician: (data: ClinicianCreateInput) => ClinicianPromise;
  updateClinician: (args: {
    data: ClinicianUpdateInput;
    where: ClinicianWhereUniqueInput;
  }) => ClinicianPromise;
  updateManyClinicians: (args: {
    data: ClinicianUpdateManyMutationInput;
    where?: ClinicianWhereInput;
  }) => BatchPayloadPromise;
  upsertClinician: (args: {
    where: ClinicianWhereUniqueInput;
    create: ClinicianCreateInput;
    update: ClinicianUpdateInput;
  }) => ClinicianPromise;
  deleteClinician: (where: ClinicianWhereUniqueInput) => ClinicianPromise;
  deleteManyClinicians: (where?: ClinicianWhereInput) => BatchPayloadPromise;
  createGroupStatus: (data: GroupStatusCreateInput) => GroupStatusPromise;
  updateGroupStatus: (args: {
    data: GroupStatusUpdateInput;
    where: GroupStatusWhereUniqueInput;
  }) => GroupStatusPromise;
  updateManyGroupStatuses: (args: {
    data: GroupStatusUpdateManyMutationInput;
    where?: GroupStatusWhereInput;
  }) => BatchPayloadPromise;
  upsertGroupStatus: (args: {
    where: GroupStatusWhereUniqueInput;
    create: GroupStatusCreateInput;
    update: GroupStatusUpdateInput;
  }) => GroupStatusPromise;
  deleteGroupStatus: (where: GroupStatusWhereUniqueInput) => GroupStatusPromise;
  deleteManyGroupStatuses: (
    where?: GroupStatusWhereInput
  ) => BatchPayloadPromise;
  createIndividualStatus: (
    data: IndividualStatusCreateInput
  ) => IndividualStatusPromise;
  updateIndividualStatus: (args: {
    data: IndividualStatusUpdateInput;
    where: IndividualStatusWhereUniqueInput;
  }) => IndividualStatusPromise;
  updateManyIndividualStatuses: (args: {
    data: IndividualStatusUpdateManyMutationInput;
    where?: IndividualStatusWhereInput;
  }) => BatchPayloadPromise;
  upsertIndividualStatus: (args: {
    where: IndividualStatusWhereUniqueInput;
    create: IndividualStatusCreateInput;
    update: IndividualStatusUpdateInput;
  }) => IndividualStatusPromise;
  deleteIndividualStatus: (
    where: IndividualStatusWhereUniqueInput
  ) => IndividualStatusPromise;
  deleteManyIndividualStatuses: (
    where?: IndividualStatusWhereInput
  ) => BatchPayloadPromise;
  createPractice: (data: PracticeCreateInput) => PracticePromise;
  updatePractice: (args: {
    data: PracticeUpdateInput;
    where: PracticeWhereUniqueInput;
  }) => PracticePromise;
  updateManyPractices: (args: {
    data: PracticeUpdateManyMutationInput;
    where?: PracticeWhereInput;
  }) => BatchPayloadPromise;
  upsertPractice: (args: {
    where: PracticeWhereUniqueInput;
    create: PracticeCreateInput;
    update: PracticeUpdateInput;
  }) => PracticePromise;
  deletePractice: (where: PracticeWhereUniqueInput) => PracticePromise;
  deleteManyPractices: (where?: PracticeWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  clinician: (
    where?: ClinicianSubscriptionWhereInput
  ) => ClinicianSubscriptionPayloadSubscription;
  groupStatus: (
    where?: GroupStatusSubscriptionWhereInput
  ) => GroupStatusSubscriptionPayloadSubscription;
  individualStatus: (
    where?: IndividualStatusSubscriptionWhereInput
  ) => IndividualStatusSubscriptionPayloadSubscription;
  practice: (
    where?: PracticeSubscriptionWhereInput
  ) => PracticeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PracticeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "enrollment_id_ASC"
  | "enrollment_id_DESC"
  | "enrollment_type_ASC"
  | "enrollment_type_DESC"
  | "first_approval_date_ASC"
  | "first_approval_date_DESC"
  | "is_enrolled_ASC"
  | "is_enrolled_DESC"
  | "last_approval_date_ASC"
  | "last_approval_date_DESC"
  | "org_name_ASC"
  | "org_name_DESC"
  | "pecos_id_ASC"
  | "pecos_id_DESC"
  | "tin_ASC"
  | "tin_DESC"
  | "tin_type_ASC"
  | "tin_type_DESC"
  | "is_sole_proprietor_ASC"
  | "is_sole_proprietor_DESC";

export type ClinicianOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "birth_state_ASC"
  | "birth_state_DESC"
  | "enrollment_id_ASC"
  | "enrollment_id_DESC"
  | "enrollment_type_ASC"
  | "enrollment_type_DESC"
  | "first_approval_date_ASC"
  | "first_approval_date_DESC"
  | "first_name_ASC"
  | "first_name_DESC"
  | "is_enrolled_ASC"
  | "is_enrolled_DESC"
  | "last_approval_date_ASC"
  | "last_approval_date_DESC"
  | "last_name_ASC"
  | "last_name_DESC"
  | "middle_name_ASC"
  | "middle_name_DESC"
  | "npi_ASC"
  | "npi_DESC"
  | "pecos_id_ASC"
  | "pecos_id_DESC";

export type GroupStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "year_ASC"
  | "year_DESC"
  | "run_ASC"
  | "run_DESC"
  | "has_aci_hardship_ASC"
  | "has_aci_hardship_DESC"
  | "has_extreme_hardship_ASC"
  | "has_extreme_hardship_DESC"
  | "has_ia_study_ASC"
  | "has_ia_study_DESC"
  | "is_hospital_based_ASC"
  | "is_hospital_based_DESC"
  | "is_low_volume_ASC"
  | "is_low_volume_DESC";

export type IndividualStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "year_ASC"
  | "year_DESC"
  | "run_ASC"
  | "run_DESC"
  | "has_aci_hardship_ASC"
  | "has_aci_hardship_DESC"
  | "has_extreme_hardship_ASC"
  | "has_extreme_hardship_DESC"
  | "has_ia_study_ASC"
  | "has_ia_study_DESC"
  | "is_hospital_based_ASC"
  | "is_hospital_based_DESC"
  | "is_low_volume_ASC"
  | "is_low_volume_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ClinicianWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PracticeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  enrollment_id?: Maybe<String>;
  enrollment_id_not?: Maybe<String>;
  enrollment_id_in?: Maybe<String[] | String>;
  enrollment_id_not_in?: Maybe<String[] | String>;
  enrollment_id_lt?: Maybe<String>;
  enrollment_id_lte?: Maybe<String>;
  enrollment_id_gt?: Maybe<String>;
  enrollment_id_gte?: Maybe<String>;
  enrollment_id_contains?: Maybe<String>;
  enrollment_id_not_contains?: Maybe<String>;
  enrollment_id_starts_with?: Maybe<String>;
  enrollment_id_not_starts_with?: Maybe<String>;
  enrollment_id_ends_with?: Maybe<String>;
  enrollment_id_not_ends_with?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  enrollment_type_not?: Maybe<String>;
  enrollment_type_in?: Maybe<String[] | String>;
  enrollment_type_not_in?: Maybe<String[] | String>;
  enrollment_type_lt?: Maybe<String>;
  enrollment_type_lte?: Maybe<String>;
  enrollment_type_gt?: Maybe<String>;
  enrollment_type_gte?: Maybe<String>;
  enrollment_type_contains?: Maybe<String>;
  enrollment_type_not_contains?: Maybe<String>;
  enrollment_type_starts_with?: Maybe<String>;
  enrollment_type_not_starts_with?: Maybe<String>;
  enrollment_type_ends_with?: Maybe<String>;
  enrollment_type_not_ends_with?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_approval_date_not?: Maybe<DateTimeInput>;
  first_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_lt?: Maybe<DateTimeInput>;
  first_approval_date_lte?: Maybe<DateTimeInput>;
  first_approval_date_gt?: Maybe<DateTimeInput>;
  first_approval_date_gte?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  is_enrolled_not?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_approval_date_not?: Maybe<DateTimeInput>;
  last_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_lt?: Maybe<DateTimeInput>;
  last_approval_date_lte?: Maybe<DateTimeInput>;
  last_approval_date_gt?: Maybe<DateTimeInput>;
  last_approval_date_gte?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  org_name_not?: Maybe<String>;
  org_name_in?: Maybe<String[] | String>;
  org_name_not_in?: Maybe<String[] | String>;
  org_name_lt?: Maybe<String>;
  org_name_lte?: Maybe<String>;
  org_name_gt?: Maybe<String>;
  org_name_gte?: Maybe<String>;
  org_name_contains?: Maybe<String>;
  org_name_not_contains?: Maybe<String>;
  org_name_starts_with?: Maybe<String>;
  org_name_not_starts_with?: Maybe<String>;
  org_name_ends_with?: Maybe<String>;
  org_name_not_ends_with?: Maybe<String>;
  pecos_id?: Maybe<String>;
  pecos_id_not?: Maybe<String>;
  pecos_id_in?: Maybe<String[] | String>;
  pecos_id_not_in?: Maybe<String[] | String>;
  pecos_id_lt?: Maybe<String>;
  pecos_id_lte?: Maybe<String>;
  pecos_id_gt?: Maybe<String>;
  pecos_id_gte?: Maybe<String>;
  pecos_id_contains?: Maybe<String>;
  pecos_id_not_contains?: Maybe<String>;
  pecos_id_starts_with?: Maybe<String>;
  pecos_id_not_starts_with?: Maybe<String>;
  pecos_id_ends_with?: Maybe<String>;
  pecos_id_not_ends_with?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_not?: Maybe<Int>;
  tin_in?: Maybe<Int[] | Int>;
  tin_not_in?: Maybe<Int[] | Int>;
  tin_lt?: Maybe<Int>;
  tin_lte?: Maybe<Int>;
  tin_gt?: Maybe<Int>;
  tin_gte?: Maybe<Int>;
  tin_type?: Maybe<String>;
  tin_type_not?: Maybe<String>;
  tin_type_in?: Maybe<String[] | String>;
  tin_type_not_in?: Maybe<String[] | String>;
  tin_type_lt?: Maybe<String>;
  tin_type_lte?: Maybe<String>;
  tin_type_gt?: Maybe<String>;
  tin_type_gte?: Maybe<String>;
  tin_type_contains?: Maybe<String>;
  tin_type_not_contains?: Maybe<String>;
  tin_type_starts_with?: Maybe<String>;
  tin_type_not_starts_with?: Maybe<String>;
  tin_type_ends_with?: Maybe<String>;
  tin_type_not_ends_with?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  is_sole_proprietor_not?: Maybe<Boolean>;
  clinicians_every?: Maybe<ClinicianWhereInput>;
  clinicians_some?: Maybe<ClinicianWhereInput>;
  clinicians_none?: Maybe<ClinicianWhereInput>;
  group_status_every?: Maybe<GroupStatusWhereInput>;
  group_status_some?: Maybe<GroupStatusWhereInput>;
  group_status_none?: Maybe<GroupStatusWhereInput>;
  AND?: Maybe<PracticeWhereInput[] | PracticeWhereInput>;
  OR?: Maybe<PracticeWhereInput[] | PracticeWhereInput>;
  NOT?: Maybe<PracticeWhereInput[] | PracticeWhereInput>;
}

export interface ClinicianWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  birth_state?: Maybe<String>;
  birth_state_not?: Maybe<String>;
  birth_state_in?: Maybe<String[] | String>;
  birth_state_not_in?: Maybe<String[] | String>;
  birth_state_lt?: Maybe<String>;
  birth_state_lte?: Maybe<String>;
  birth_state_gt?: Maybe<String>;
  birth_state_gte?: Maybe<String>;
  birth_state_contains?: Maybe<String>;
  birth_state_not_contains?: Maybe<String>;
  birth_state_starts_with?: Maybe<String>;
  birth_state_not_starts_with?: Maybe<String>;
  birth_state_ends_with?: Maybe<String>;
  birth_state_not_ends_with?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_id_not?: Maybe<String>;
  enrollment_id_in?: Maybe<String[] | String>;
  enrollment_id_not_in?: Maybe<String[] | String>;
  enrollment_id_lt?: Maybe<String>;
  enrollment_id_lte?: Maybe<String>;
  enrollment_id_gt?: Maybe<String>;
  enrollment_id_gte?: Maybe<String>;
  enrollment_id_contains?: Maybe<String>;
  enrollment_id_not_contains?: Maybe<String>;
  enrollment_id_starts_with?: Maybe<String>;
  enrollment_id_not_starts_with?: Maybe<String>;
  enrollment_id_ends_with?: Maybe<String>;
  enrollment_id_not_ends_with?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  enrollment_type_not?: Maybe<String>;
  enrollment_type_in?: Maybe<String[] | String>;
  enrollment_type_not_in?: Maybe<String[] | String>;
  enrollment_type_lt?: Maybe<String>;
  enrollment_type_lte?: Maybe<String>;
  enrollment_type_gt?: Maybe<String>;
  enrollment_type_gte?: Maybe<String>;
  enrollment_type_contains?: Maybe<String>;
  enrollment_type_not_contains?: Maybe<String>;
  enrollment_type_starts_with?: Maybe<String>;
  enrollment_type_not_starts_with?: Maybe<String>;
  enrollment_type_ends_with?: Maybe<String>;
  enrollment_type_not_ends_with?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_approval_date_not?: Maybe<DateTimeInput>;
  first_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_lt?: Maybe<DateTimeInput>;
  first_approval_date_lte?: Maybe<DateTimeInput>;
  first_approval_date_gt?: Maybe<DateTimeInput>;
  first_approval_date_gte?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  first_name_not?: Maybe<String>;
  first_name_in?: Maybe<String[] | String>;
  first_name_not_in?: Maybe<String[] | String>;
  first_name_lt?: Maybe<String>;
  first_name_lte?: Maybe<String>;
  first_name_gt?: Maybe<String>;
  first_name_gte?: Maybe<String>;
  first_name_contains?: Maybe<String>;
  first_name_not_contains?: Maybe<String>;
  first_name_starts_with?: Maybe<String>;
  first_name_not_starts_with?: Maybe<String>;
  first_name_ends_with?: Maybe<String>;
  first_name_not_ends_with?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  is_enrolled_not?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_approval_date_not?: Maybe<DateTimeInput>;
  last_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_lt?: Maybe<DateTimeInput>;
  last_approval_date_lte?: Maybe<DateTimeInput>;
  last_approval_date_gt?: Maybe<DateTimeInput>;
  last_approval_date_gte?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  last_name_not?: Maybe<String>;
  last_name_in?: Maybe<String[] | String>;
  last_name_not_in?: Maybe<String[] | String>;
  last_name_lt?: Maybe<String>;
  last_name_lte?: Maybe<String>;
  last_name_gt?: Maybe<String>;
  last_name_gte?: Maybe<String>;
  last_name_contains?: Maybe<String>;
  last_name_not_contains?: Maybe<String>;
  last_name_starts_with?: Maybe<String>;
  last_name_not_starts_with?: Maybe<String>;
  last_name_ends_with?: Maybe<String>;
  last_name_not_ends_with?: Maybe<String>;
  middle_name?: Maybe<String>;
  middle_name_not?: Maybe<String>;
  middle_name_in?: Maybe<String[] | String>;
  middle_name_not_in?: Maybe<String[] | String>;
  middle_name_lt?: Maybe<String>;
  middle_name_lte?: Maybe<String>;
  middle_name_gt?: Maybe<String>;
  middle_name_gte?: Maybe<String>;
  middle_name_contains?: Maybe<String>;
  middle_name_not_contains?: Maybe<String>;
  middle_name_starts_with?: Maybe<String>;
  middle_name_not_starts_with?: Maybe<String>;
  middle_name_ends_with?: Maybe<String>;
  middle_name_not_ends_with?: Maybe<String>;
  npi?: Maybe<Int>;
  npi_not?: Maybe<Int>;
  npi_in?: Maybe<Int[] | Int>;
  npi_not_in?: Maybe<Int[] | Int>;
  npi_lt?: Maybe<Int>;
  npi_lte?: Maybe<Int>;
  npi_gt?: Maybe<Int>;
  npi_gte?: Maybe<Int>;
  pecos_id?: Maybe<String>;
  pecos_id_not?: Maybe<String>;
  pecos_id_in?: Maybe<String[] | String>;
  pecos_id_not_in?: Maybe<String[] | String>;
  pecos_id_lt?: Maybe<String>;
  pecos_id_lte?: Maybe<String>;
  pecos_id_gt?: Maybe<String>;
  pecos_id_gte?: Maybe<String>;
  pecos_id_contains?: Maybe<String>;
  pecos_id_not_contains?: Maybe<String>;
  pecos_id_starts_with?: Maybe<String>;
  pecos_id_not_starts_with?: Maybe<String>;
  pecos_id_ends_with?: Maybe<String>;
  pecos_id_not_ends_with?: Maybe<String>;
  practices_every?: Maybe<PracticeWhereInput>;
  practices_some?: Maybe<PracticeWhereInput>;
  practices_none?: Maybe<PracticeWhereInput>;
  AND?: Maybe<ClinicianWhereInput[] | ClinicianWhereInput>;
  OR?: Maybe<ClinicianWhereInput[] | ClinicianWhereInput>;
  NOT?: Maybe<ClinicianWhereInput[] | ClinicianWhereInput>;
}

export interface GroupStatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  run?: Maybe<Int>;
  run_not?: Maybe<Int>;
  run_in?: Maybe<Int[] | Int>;
  run_not_in?: Maybe<Int[] | Int>;
  run_lt?: Maybe<Int>;
  run_lte?: Maybe<Int>;
  run_gt?: Maybe<Int>;
  run_gte?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_aci_hardship_not?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_extreme_hardship_not?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  has_ia_study_not?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_hospital_based_not?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
  is_low_volume_not?: Maybe<Boolean>;
  practice?: Maybe<PracticeWhereInput>;
  AND?: Maybe<GroupStatusWhereInput[] | GroupStatusWhereInput>;
  OR?: Maybe<GroupStatusWhereInput[] | GroupStatusWhereInput>;
  NOT?: Maybe<GroupStatusWhereInput[] | GroupStatusWhereInput>;
}

export type GroupStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type IndividualStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IndividualStatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  clinician?: Maybe<ClinicianWhereInput>;
  practice?: Maybe<PracticeWhereInput>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  run?: Maybe<Int>;
  run_not?: Maybe<Int>;
  run_in?: Maybe<Int[] | Int>;
  run_not_in?: Maybe<Int[] | Int>;
  run_lt?: Maybe<Int>;
  run_lte?: Maybe<Int>;
  run_gt?: Maybe<Int>;
  run_gte?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_aci_hardship_not?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_extreme_hardship_not?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  has_ia_study_not?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_hospital_based_not?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
  is_low_volume_not?: Maybe<Boolean>;
  AND?: Maybe<IndividualStatusWhereInput[] | IndividualStatusWhereInput>;
  OR?: Maybe<IndividualStatusWhereInput[] | IndividualStatusWhereInput>;
  NOT?: Maybe<IndividualStatusWhereInput[] | IndividualStatusWhereInput>;
}

export type PracticeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ClinicianCreateInput {
  id?: Maybe<ID_Input>;
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi: Int;
  pecos_id?: Maybe<String>;
  practices?: Maybe<PracticeCreateManyWithoutCliniciansInput>;
}

export interface PracticeCreateManyWithoutCliniciansInput {
  create?: Maybe<
    | PracticeCreateWithoutCliniciansInput[]
    | PracticeCreateWithoutCliniciansInput
  >;
  connect?: Maybe<PracticeWhereUniqueInput[] | PracticeWhereUniqueInput>;
}

export interface PracticeCreateWithoutCliniciansInput {
  id?: Maybe<ID_Input>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin: Int;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  group_status?: Maybe<GroupStatusCreateManyWithoutPracticeInput>;
}

export interface GroupStatusCreateManyWithoutPracticeInput {
  create?: Maybe<
    | GroupStatusCreateWithoutPracticeInput[]
    | GroupStatusCreateWithoutPracticeInput
  >;
  connect?: Maybe<GroupStatusWhereUniqueInput[] | GroupStatusWhereUniqueInput>;
}

export interface GroupStatusCreateWithoutPracticeInput {
  id?: Maybe<ID_Input>;
  year: Int;
  run: Int;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface ClinicianUpdateInput {
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi?: Maybe<Int>;
  pecos_id?: Maybe<String>;
  practices?: Maybe<PracticeUpdateManyWithoutCliniciansInput>;
}

export interface PracticeUpdateManyWithoutCliniciansInput {
  create?: Maybe<
    | PracticeCreateWithoutCliniciansInput[]
    | PracticeCreateWithoutCliniciansInput
  >;
  delete?: Maybe<PracticeWhereUniqueInput[] | PracticeWhereUniqueInput>;
  connect?: Maybe<PracticeWhereUniqueInput[] | PracticeWhereUniqueInput>;
  set?: Maybe<PracticeWhereUniqueInput[] | PracticeWhereUniqueInput>;
  disconnect?: Maybe<PracticeWhereUniqueInput[] | PracticeWhereUniqueInput>;
  update?: Maybe<
    | PracticeUpdateWithWhereUniqueWithoutCliniciansInput[]
    | PracticeUpdateWithWhereUniqueWithoutCliniciansInput
  >;
  upsert?: Maybe<
    | PracticeUpsertWithWhereUniqueWithoutCliniciansInput[]
    | PracticeUpsertWithWhereUniqueWithoutCliniciansInput
  >;
  deleteMany?: Maybe<PracticeScalarWhereInput[] | PracticeScalarWhereInput>;
  updateMany?: Maybe<
    | PracticeUpdateManyWithWhereNestedInput[]
    | PracticeUpdateManyWithWhereNestedInput
  >;
}

export interface PracticeUpdateWithWhereUniqueWithoutCliniciansInput {
  where: PracticeWhereUniqueInput;
  data: PracticeUpdateWithoutCliniciansDataInput;
}

export interface PracticeUpdateWithoutCliniciansDataInput {
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  group_status?: Maybe<GroupStatusUpdateManyWithoutPracticeInput>;
}

export interface GroupStatusUpdateManyWithoutPracticeInput {
  create?: Maybe<
    | GroupStatusCreateWithoutPracticeInput[]
    | GroupStatusCreateWithoutPracticeInput
  >;
  delete?: Maybe<GroupStatusWhereUniqueInput[] | GroupStatusWhereUniqueInput>;
  connect?: Maybe<GroupStatusWhereUniqueInput[] | GroupStatusWhereUniqueInput>;
  set?: Maybe<GroupStatusWhereUniqueInput[] | GroupStatusWhereUniqueInput>;
  disconnect?: Maybe<
    GroupStatusWhereUniqueInput[] | GroupStatusWhereUniqueInput
  >;
  update?: Maybe<
    | GroupStatusUpdateWithWhereUniqueWithoutPracticeInput[]
    | GroupStatusUpdateWithWhereUniqueWithoutPracticeInput
  >;
  upsert?: Maybe<
    | GroupStatusUpsertWithWhereUniqueWithoutPracticeInput[]
    | GroupStatusUpsertWithWhereUniqueWithoutPracticeInput
  >;
  deleteMany?: Maybe<
    GroupStatusScalarWhereInput[] | GroupStatusScalarWhereInput
  >;
  updateMany?: Maybe<
    | GroupStatusUpdateManyWithWhereNestedInput[]
    | GroupStatusUpdateManyWithWhereNestedInput
  >;
}

export interface GroupStatusUpdateWithWhereUniqueWithoutPracticeInput {
  where: GroupStatusWhereUniqueInput;
  data: GroupStatusUpdateWithoutPracticeDataInput;
}

export interface GroupStatusUpdateWithoutPracticeDataInput {
  year?: Maybe<Int>;
  run?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface GroupStatusUpsertWithWhereUniqueWithoutPracticeInput {
  where: GroupStatusWhereUniqueInput;
  update: GroupStatusUpdateWithoutPracticeDataInput;
  create: GroupStatusCreateWithoutPracticeInput;
}

export interface GroupStatusScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  run?: Maybe<Int>;
  run_not?: Maybe<Int>;
  run_in?: Maybe<Int[] | Int>;
  run_not_in?: Maybe<Int[] | Int>;
  run_lt?: Maybe<Int>;
  run_lte?: Maybe<Int>;
  run_gt?: Maybe<Int>;
  run_gte?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_aci_hardship_not?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_extreme_hardship_not?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  has_ia_study_not?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_hospital_based_not?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
  is_low_volume_not?: Maybe<Boolean>;
  AND?: Maybe<GroupStatusScalarWhereInput[] | GroupStatusScalarWhereInput>;
  OR?: Maybe<GroupStatusScalarWhereInput[] | GroupStatusScalarWhereInput>;
  NOT?: Maybe<GroupStatusScalarWhereInput[] | GroupStatusScalarWhereInput>;
}

export interface GroupStatusUpdateManyWithWhereNestedInput {
  where: GroupStatusScalarWhereInput;
  data: GroupStatusUpdateManyDataInput;
}

export interface GroupStatusUpdateManyDataInput {
  year?: Maybe<Int>;
  run?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface PracticeUpsertWithWhereUniqueWithoutCliniciansInput {
  where: PracticeWhereUniqueInput;
  update: PracticeUpdateWithoutCliniciansDataInput;
  create: PracticeCreateWithoutCliniciansInput;
}

export interface PracticeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  enrollment_id?: Maybe<String>;
  enrollment_id_not?: Maybe<String>;
  enrollment_id_in?: Maybe<String[] | String>;
  enrollment_id_not_in?: Maybe<String[] | String>;
  enrollment_id_lt?: Maybe<String>;
  enrollment_id_lte?: Maybe<String>;
  enrollment_id_gt?: Maybe<String>;
  enrollment_id_gte?: Maybe<String>;
  enrollment_id_contains?: Maybe<String>;
  enrollment_id_not_contains?: Maybe<String>;
  enrollment_id_starts_with?: Maybe<String>;
  enrollment_id_not_starts_with?: Maybe<String>;
  enrollment_id_ends_with?: Maybe<String>;
  enrollment_id_not_ends_with?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  enrollment_type_not?: Maybe<String>;
  enrollment_type_in?: Maybe<String[] | String>;
  enrollment_type_not_in?: Maybe<String[] | String>;
  enrollment_type_lt?: Maybe<String>;
  enrollment_type_lte?: Maybe<String>;
  enrollment_type_gt?: Maybe<String>;
  enrollment_type_gte?: Maybe<String>;
  enrollment_type_contains?: Maybe<String>;
  enrollment_type_not_contains?: Maybe<String>;
  enrollment_type_starts_with?: Maybe<String>;
  enrollment_type_not_starts_with?: Maybe<String>;
  enrollment_type_ends_with?: Maybe<String>;
  enrollment_type_not_ends_with?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_approval_date_not?: Maybe<DateTimeInput>;
  first_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_lt?: Maybe<DateTimeInput>;
  first_approval_date_lte?: Maybe<DateTimeInput>;
  first_approval_date_gt?: Maybe<DateTimeInput>;
  first_approval_date_gte?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  is_enrolled_not?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_approval_date_not?: Maybe<DateTimeInput>;
  last_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_lt?: Maybe<DateTimeInput>;
  last_approval_date_lte?: Maybe<DateTimeInput>;
  last_approval_date_gt?: Maybe<DateTimeInput>;
  last_approval_date_gte?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  org_name_not?: Maybe<String>;
  org_name_in?: Maybe<String[] | String>;
  org_name_not_in?: Maybe<String[] | String>;
  org_name_lt?: Maybe<String>;
  org_name_lte?: Maybe<String>;
  org_name_gt?: Maybe<String>;
  org_name_gte?: Maybe<String>;
  org_name_contains?: Maybe<String>;
  org_name_not_contains?: Maybe<String>;
  org_name_starts_with?: Maybe<String>;
  org_name_not_starts_with?: Maybe<String>;
  org_name_ends_with?: Maybe<String>;
  org_name_not_ends_with?: Maybe<String>;
  pecos_id?: Maybe<String>;
  pecos_id_not?: Maybe<String>;
  pecos_id_in?: Maybe<String[] | String>;
  pecos_id_not_in?: Maybe<String[] | String>;
  pecos_id_lt?: Maybe<String>;
  pecos_id_lte?: Maybe<String>;
  pecos_id_gt?: Maybe<String>;
  pecos_id_gte?: Maybe<String>;
  pecos_id_contains?: Maybe<String>;
  pecos_id_not_contains?: Maybe<String>;
  pecos_id_starts_with?: Maybe<String>;
  pecos_id_not_starts_with?: Maybe<String>;
  pecos_id_ends_with?: Maybe<String>;
  pecos_id_not_ends_with?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_not?: Maybe<Int>;
  tin_in?: Maybe<Int[] | Int>;
  tin_not_in?: Maybe<Int[] | Int>;
  tin_lt?: Maybe<Int>;
  tin_lte?: Maybe<Int>;
  tin_gt?: Maybe<Int>;
  tin_gte?: Maybe<Int>;
  tin_type?: Maybe<String>;
  tin_type_not?: Maybe<String>;
  tin_type_in?: Maybe<String[] | String>;
  tin_type_not_in?: Maybe<String[] | String>;
  tin_type_lt?: Maybe<String>;
  tin_type_lte?: Maybe<String>;
  tin_type_gt?: Maybe<String>;
  tin_type_gte?: Maybe<String>;
  tin_type_contains?: Maybe<String>;
  tin_type_not_contains?: Maybe<String>;
  tin_type_starts_with?: Maybe<String>;
  tin_type_not_starts_with?: Maybe<String>;
  tin_type_ends_with?: Maybe<String>;
  tin_type_not_ends_with?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  is_sole_proprietor_not?: Maybe<Boolean>;
  AND?: Maybe<PracticeScalarWhereInput[] | PracticeScalarWhereInput>;
  OR?: Maybe<PracticeScalarWhereInput[] | PracticeScalarWhereInput>;
  NOT?: Maybe<PracticeScalarWhereInput[] | PracticeScalarWhereInput>;
}

export interface PracticeUpdateManyWithWhereNestedInput {
  where: PracticeScalarWhereInput;
  data: PracticeUpdateManyDataInput;
}

export interface PracticeUpdateManyDataInput {
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
}

export interface ClinicianUpdateManyMutationInput {
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi?: Maybe<Int>;
  pecos_id?: Maybe<String>;
}

export interface GroupStatusCreateInput {
  id?: Maybe<ID_Input>;
  year: Int;
  run: Int;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
  practice: PracticeCreateOneWithoutGroup_statusInput;
}

export interface PracticeCreateOneWithoutGroup_statusInput {
  create?: Maybe<PracticeCreateWithoutGroup_statusInput>;
  connect?: Maybe<PracticeWhereUniqueInput>;
}

export interface PracticeCreateWithoutGroup_statusInput {
  id?: Maybe<ID_Input>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin: Int;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  clinicians?: Maybe<ClinicianCreateManyWithoutPracticesInput>;
}

export interface ClinicianCreateManyWithoutPracticesInput {
  create?: Maybe<
    | ClinicianCreateWithoutPracticesInput[]
    | ClinicianCreateWithoutPracticesInput
  >;
  connect?: Maybe<ClinicianWhereUniqueInput[] | ClinicianWhereUniqueInput>;
}

export interface ClinicianCreateWithoutPracticesInput {
  id?: Maybe<ID_Input>;
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi: Int;
  pecos_id?: Maybe<String>;
}

export interface GroupStatusUpdateInput {
  year?: Maybe<Int>;
  run?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
  practice?: Maybe<PracticeUpdateOneRequiredWithoutGroup_statusInput>;
}

export interface PracticeUpdateOneRequiredWithoutGroup_statusInput {
  create?: Maybe<PracticeCreateWithoutGroup_statusInput>;
  update?: Maybe<PracticeUpdateWithoutGroup_statusDataInput>;
  upsert?: Maybe<PracticeUpsertWithoutGroup_statusInput>;
  connect?: Maybe<PracticeWhereUniqueInput>;
}

export interface PracticeUpdateWithoutGroup_statusDataInput {
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  clinicians?: Maybe<ClinicianUpdateManyWithoutPracticesInput>;
}

export interface ClinicianUpdateManyWithoutPracticesInput {
  create?: Maybe<
    | ClinicianCreateWithoutPracticesInput[]
    | ClinicianCreateWithoutPracticesInput
  >;
  delete?: Maybe<ClinicianWhereUniqueInput[] | ClinicianWhereUniqueInput>;
  connect?: Maybe<ClinicianWhereUniqueInput[] | ClinicianWhereUniqueInput>;
  set?: Maybe<ClinicianWhereUniqueInput[] | ClinicianWhereUniqueInput>;
  disconnect?: Maybe<ClinicianWhereUniqueInput[] | ClinicianWhereUniqueInput>;
  update?: Maybe<
    | ClinicianUpdateWithWhereUniqueWithoutPracticesInput[]
    | ClinicianUpdateWithWhereUniqueWithoutPracticesInput
  >;
  upsert?: Maybe<
    | ClinicianUpsertWithWhereUniqueWithoutPracticesInput[]
    | ClinicianUpsertWithWhereUniqueWithoutPracticesInput
  >;
  deleteMany?: Maybe<ClinicianScalarWhereInput[] | ClinicianScalarWhereInput>;
  updateMany?: Maybe<
    | ClinicianUpdateManyWithWhereNestedInput[]
    | ClinicianUpdateManyWithWhereNestedInput
  >;
}

export interface ClinicianUpdateWithWhereUniqueWithoutPracticesInput {
  where: ClinicianWhereUniqueInput;
  data: ClinicianUpdateWithoutPracticesDataInput;
}

export interface ClinicianUpdateWithoutPracticesDataInput {
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi?: Maybe<Int>;
  pecos_id?: Maybe<String>;
}

export interface ClinicianUpsertWithWhereUniqueWithoutPracticesInput {
  where: ClinicianWhereUniqueInput;
  update: ClinicianUpdateWithoutPracticesDataInput;
  create: ClinicianCreateWithoutPracticesInput;
}

export interface ClinicianScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  birth_state?: Maybe<String>;
  birth_state_not?: Maybe<String>;
  birth_state_in?: Maybe<String[] | String>;
  birth_state_not_in?: Maybe<String[] | String>;
  birth_state_lt?: Maybe<String>;
  birth_state_lte?: Maybe<String>;
  birth_state_gt?: Maybe<String>;
  birth_state_gte?: Maybe<String>;
  birth_state_contains?: Maybe<String>;
  birth_state_not_contains?: Maybe<String>;
  birth_state_starts_with?: Maybe<String>;
  birth_state_not_starts_with?: Maybe<String>;
  birth_state_ends_with?: Maybe<String>;
  birth_state_not_ends_with?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_id_not?: Maybe<String>;
  enrollment_id_in?: Maybe<String[] | String>;
  enrollment_id_not_in?: Maybe<String[] | String>;
  enrollment_id_lt?: Maybe<String>;
  enrollment_id_lte?: Maybe<String>;
  enrollment_id_gt?: Maybe<String>;
  enrollment_id_gte?: Maybe<String>;
  enrollment_id_contains?: Maybe<String>;
  enrollment_id_not_contains?: Maybe<String>;
  enrollment_id_starts_with?: Maybe<String>;
  enrollment_id_not_starts_with?: Maybe<String>;
  enrollment_id_ends_with?: Maybe<String>;
  enrollment_id_not_ends_with?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  enrollment_type_not?: Maybe<String>;
  enrollment_type_in?: Maybe<String[] | String>;
  enrollment_type_not_in?: Maybe<String[] | String>;
  enrollment_type_lt?: Maybe<String>;
  enrollment_type_lte?: Maybe<String>;
  enrollment_type_gt?: Maybe<String>;
  enrollment_type_gte?: Maybe<String>;
  enrollment_type_contains?: Maybe<String>;
  enrollment_type_not_contains?: Maybe<String>;
  enrollment_type_starts_with?: Maybe<String>;
  enrollment_type_not_starts_with?: Maybe<String>;
  enrollment_type_ends_with?: Maybe<String>;
  enrollment_type_not_ends_with?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_approval_date_not?: Maybe<DateTimeInput>;
  first_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  first_approval_date_lt?: Maybe<DateTimeInput>;
  first_approval_date_lte?: Maybe<DateTimeInput>;
  first_approval_date_gt?: Maybe<DateTimeInput>;
  first_approval_date_gte?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  first_name_not?: Maybe<String>;
  first_name_in?: Maybe<String[] | String>;
  first_name_not_in?: Maybe<String[] | String>;
  first_name_lt?: Maybe<String>;
  first_name_lte?: Maybe<String>;
  first_name_gt?: Maybe<String>;
  first_name_gte?: Maybe<String>;
  first_name_contains?: Maybe<String>;
  first_name_not_contains?: Maybe<String>;
  first_name_starts_with?: Maybe<String>;
  first_name_not_starts_with?: Maybe<String>;
  first_name_ends_with?: Maybe<String>;
  first_name_not_ends_with?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  is_enrolled_not?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_approval_date_not?: Maybe<DateTimeInput>;
  last_approval_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  last_approval_date_lt?: Maybe<DateTimeInput>;
  last_approval_date_lte?: Maybe<DateTimeInput>;
  last_approval_date_gt?: Maybe<DateTimeInput>;
  last_approval_date_gte?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  last_name_not?: Maybe<String>;
  last_name_in?: Maybe<String[] | String>;
  last_name_not_in?: Maybe<String[] | String>;
  last_name_lt?: Maybe<String>;
  last_name_lte?: Maybe<String>;
  last_name_gt?: Maybe<String>;
  last_name_gte?: Maybe<String>;
  last_name_contains?: Maybe<String>;
  last_name_not_contains?: Maybe<String>;
  last_name_starts_with?: Maybe<String>;
  last_name_not_starts_with?: Maybe<String>;
  last_name_ends_with?: Maybe<String>;
  last_name_not_ends_with?: Maybe<String>;
  middle_name?: Maybe<String>;
  middle_name_not?: Maybe<String>;
  middle_name_in?: Maybe<String[] | String>;
  middle_name_not_in?: Maybe<String[] | String>;
  middle_name_lt?: Maybe<String>;
  middle_name_lte?: Maybe<String>;
  middle_name_gt?: Maybe<String>;
  middle_name_gte?: Maybe<String>;
  middle_name_contains?: Maybe<String>;
  middle_name_not_contains?: Maybe<String>;
  middle_name_starts_with?: Maybe<String>;
  middle_name_not_starts_with?: Maybe<String>;
  middle_name_ends_with?: Maybe<String>;
  middle_name_not_ends_with?: Maybe<String>;
  npi?: Maybe<Int>;
  npi_not?: Maybe<Int>;
  npi_in?: Maybe<Int[] | Int>;
  npi_not_in?: Maybe<Int[] | Int>;
  npi_lt?: Maybe<Int>;
  npi_lte?: Maybe<Int>;
  npi_gt?: Maybe<Int>;
  npi_gte?: Maybe<Int>;
  pecos_id?: Maybe<String>;
  pecos_id_not?: Maybe<String>;
  pecos_id_in?: Maybe<String[] | String>;
  pecos_id_not_in?: Maybe<String[] | String>;
  pecos_id_lt?: Maybe<String>;
  pecos_id_lte?: Maybe<String>;
  pecos_id_gt?: Maybe<String>;
  pecos_id_gte?: Maybe<String>;
  pecos_id_contains?: Maybe<String>;
  pecos_id_not_contains?: Maybe<String>;
  pecos_id_starts_with?: Maybe<String>;
  pecos_id_not_starts_with?: Maybe<String>;
  pecos_id_ends_with?: Maybe<String>;
  pecos_id_not_ends_with?: Maybe<String>;
  AND?: Maybe<ClinicianScalarWhereInput[] | ClinicianScalarWhereInput>;
  OR?: Maybe<ClinicianScalarWhereInput[] | ClinicianScalarWhereInput>;
  NOT?: Maybe<ClinicianScalarWhereInput[] | ClinicianScalarWhereInput>;
}

export interface ClinicianUpdateManyWithWhereNestedInput {
  where: ClinicianScalarWhereInput;
  data: ClinicianUpdateManyDataInput;
}

export interface ClinicianUpdateManyDataInput {
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi?: Maybe<Int>;
  pecos_id?: Maybe<String>;
}

export interface PracticeUpsertWithoutGroup_statusInput {
  update: PracticeUpdateWithoutGroup_statusDataInput;
  create: PracticeCreateWithoutGroup_statusInput;
}

export interface GroupStatusUpdateManyMutationInput {
  year?: Maybe<Int>;
  run?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface IndividualStatusCreateInput {
  id?: Maybe<ID_Input>;
  clinician: ClinicianCreateOneInput;
  practice: PracticeCreateOneInput;
  year: Int;
  run: Int;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface ClinicianCreateOneInput {
  create?: Maybe<ClinicianCreateInput>;
  connect?: Maybe<ClinicianWhereUniqueInput>;
}

export interface PracticeCreateOneInput {
  create?: Maybe<PracticeCreateInput>;
  connect?: Maybe<PracticeWhereUniqueInput>;
}

export interface PracticeCreateInput {
  id?: Maybe<ID_Input>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin: Int;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  clinicians?: Maybe<ClinicianCreateManyWithoutPracticesInput>;
  group_status?: Maybe<GroupStatusCreateManyWithoutPracticeInput>;
}

export interface IndividualStatusUpdateInput {
  clinician?: Maybe<ClinicianUpdateOneRequiredInput>;
  practice?: Maybe<PracticeUpdateOneRequiredInput>;
  year?: Maybe<Int>;
  run?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface ClinicianUpdateOneRequiredInput {
  create?: Maybe<ClinicianCreateInput>;
  update?: Maybe<ClinicianUpdateDataInput>;
  upsert?: Maybe<ClinicianUpsertNestedInput>;
  connect?: Maybe<ClinicianWhereUniqueInput>;
}

export interface ClinicianUpdateDataInput {
  birth_state?: Maybe<String>;
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  last_name?: Maybe<String>;
  middle_name?: Maybe<String>;
  npi?: Maybe<Int>;
  pecos_id?: Maybe<String>;
  practices?: Maybe<PracticeUpdateManyWithoutCliniciansInput>;
}

export interface ClinicianUpsertNestedInput {
  update: ClinicianUpdateDataInput;
  create: ClinicianCreateInput;
}

export interface PracticeUpdateOneRequiredInput {
  create?: Maybe<PracticeCreateInput>;
  update?: Maybe<PracticeUpdateDataInput>;
  upsert?: Maybe<PracticeUpsertNestedInput>;
  connect?: Maybe<PracticeWhereUniqueInput>;
}

export interface PracticeUpdateDataInput {
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  clinicians?: Maybe<ClinicianUpdateManyWithoutPracticesInput>;
  group_status?: Maybe<GroupStatusUpdateManyWithoutPracticeInput>;
}

export interface PracticeUpsertNestedInput {
  update: PracticeUpdateDataInput;
  create: PracticeCreateInput;
}

export interface IndividualStatusUpdateManyMutationInput {
  year?: Maybe<Int>;
  run?: Maybe<Int>;
  has_aci_hardship?: Maybe<Boolean>;
  has_extreme_hardship?: Maybe<Boolean>;
  has_ia_study?: Maybe<Boolean>;
  is_hospital_based?: Maybe<Boolean>;
  is_low_volume?: Maybe<Boolean>;
}

export interface PracticeUpdateInput {
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
  clinicians?: Maybe<ClinicianUpdateManyWithoutPracticesInput>;
  group_status?: Maybe<GroupStatusUpdateManyWithoutPracticeInput>;
}

export interface PracticeUpdateManyMutationInput {
  enrollment_id?: Maybe<String>;
  enrollment_type?: Maybe<String>;
  first_approval_date?: Maybe<DateTimeInput>;
  is_enrolled?: Maybe<Boolean>;
  last_approval_date?: Maybe<DateTimeInput>;
  org_name?: Maybe<String>;
  pecos_id?: Maybe<String>;
  tin?: Maybe<Int>;
  tin_type?: Maybe<String>;
  is_sole_proprietor?: Maybe<Boolean>;
}

export interface ClinicianSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClinicianWhereInput>;
  AND?: Maybe<
    ClinicianSubscriptionWhereInput[] | ClinicianSubscriptionWhereInput
  >;
  OR?: Maybe<
    ClinicianSubscriptionWhereInput[] | ClinicianSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ClinicianSubscriptionWhereInput[] | ClinicianSubscriptionWhereInput
  >;
}

export interface GroupStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GroupStatusWhereInput>;
  AND?: Maybe<
    GroupStatusSubscriptionWhereInput[] | GroupStatusSubscriptionWhereInput
  >;
  OR?: Maybe<
    GroupStatusSubscriptionWhereInput[] | GroupStatusSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GroupStatusSubscriptionWhereInput[] | GroupStatusSubscriptionWhereInput
  >;
}

export interface IndividualStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IndividualStatusWhereInput>;
  AND?: Maybe<
    | IndividualStatusSubscriptionWhereInput[]
    | IndividualStatusSubscriptionWhereInput
  >;
  OR?: Maybe<
    | IndividualStatusSubscriptionWhereInput[]
    | IndividualStatusSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | IndividualStatusSubscriptionWhereInput[]
    | IndividualStatusSubscriptionWhereInput
  >;
}

export interface PracticeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PracticeWhereInput>;
  AND?: Maybe<
    PracticeSubscriptionWhereInput[] | PracticeSubscriptionWhereInput
  >;
  OR?: Maybe<PracticeSubscriptionWhereInput[] | PracticeSubscriptionWhereInput>;
  NOT?: Maybe<
    PracticeSubscriptionWhereInput[] | PracticeSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Clinician {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  birth_state?: String;
  enrollment_id?: String;
  enrollment_type?: String;
  first_approval_date?: DateTimeOutput;
  first_name?: String;
  is_enrolled?: Boolean;
  last_approval_date?: DateTimeOutput;
  last_name?: String;
  middle_name?: String;
  npi: Int;
  pecos_id?: String;
}

export interface ClinicianPromise extends Promise<Clinician>, Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  birth_state: () => Promise<String>;
  enrollment_id: () => Promise<String>;
  enrollment_type: () => Promise<String>;
  first_approval_date: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  is_enrolled: () => Promise<Boolean>;
  last_approval_date: () => Promise<DateTimeOutput>;
  last_name: () => Promise<String>;
  middle_name: () => Promise<String>;
  npi: () => Promise<Int>;
  pecos_id: () => Promise<String>;
  practices: <T = FragmentableArray<Practice>>(args?: {
    where?: PracticeWhereInput;
    orderBy?: PracticeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClinicianSubscription
  extends Promise<AsyncIterator<Clinician>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  birth_state: () => Promise<AsyncIterator<String>>;
  enrollment_id: () => Promise<AsyncIterator<String>>;
  enrollment_type: () => Promise<AsyncIterator<String>>;
  first_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  first_name: () => Promise<AsyncIterator<String>>;
  is_enrolled: () => Promise<AsyncIterator<Boolean>>;
  last_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  last_name: () => Promise<AsyncIterator<String>>;
  middle_name: () => Promise<AsyncIterator<String>>;
  npi: () => Promise<AsyncIterator<Int>>;
  pecos_id: () => Promise<AsyncIterator<String>>;
  practices: <T = Promise<AsyncIterator<PracticeSubscription>>>(args?: {
    where?: PracticeWhereInput;
    orderBy?: PracticeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClinicianNullablePromise
  extends Promise<Clinician | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  birth_state: () => Promise<String>;
  enrollment_id: () => Promise<String>;
  enrollment_type: () => Promise<String>;
  first_approval_date: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  is_enrolled: () => Promise<Boolean>;
  last_approval_date: () => Promise<DateTimeOutput>;
  last_name: () => Promise<String>;
  middle_name: () => Promise<String>;
  npi: () => Promise<Int>;
  pecos_id: () => Promise<String>;
  practices: <T = FragmentableArray<Practice>>(args?: {
    where?: PracticeWhereInput;
    orderBy?: PracticeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Practice {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  enrollment_id?: String;
  enrollment_type?: String;
  first_approval_date?: DateTimeOutput;
  is_enrolled?: Boolean;
  last_approval_date?: DateTimeOutput;
  org_name?: String;
  pecos_id?: String;
  tin: Int;
  tin_type?: String;
  is_sole_proprietor?: Boolean;
}

export interface PracticePromise extends Promise<Practice>, Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  enrollment_id: () => Promise<String>;
  enrollment_type: () => Promise<String>;
  first_approval_date: () => Promise<DateTimeOutput>;
  is_enrolled: () => Promise<Boolean>;
  last_approval_date: () => Promise<DateTimeOutput>;
  org_name: () => Promise<String>;
  pecos_id: () => Promise<String>;
  tin: () => Promise<Int>;
  tin_type: () => Promise<String>;
  is_sole_proprietor: () => Promise<Boolean>;
  clinicians: <T = FragmentableArray<Clinician>>(args?: {
    where?: ClinicianWhereInput;
    orderBy?: ClinicianOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group_status: <T = FragmentableArray<GroupStatus>>(args?: {
    where?: GroupStatusWhereInput;
    orderBy?: GroupStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PracticeSubscription
  extends Promise<AsyncIterator<Practice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  enrollment_id: () => Promise<AsyncIterator<String>>;
  enrollment_type: () => Promise<AsyncIterator<String>>;
  first_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  is_enrolled: () => Promise<AsyncIterator<Boolean>>;
  last_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  org_name: () => Promise<AsyncIterator<String>>;
  pecos_id: () => Promise<AsyncIterator<String>>;
  tin: () => Promise<AsyncIterator<Int>>;
  tin_type: () => Promise<AsyncIterator<String>>;
  is_sole_proprietor: () => Promise<AsyncIterator<Boolean>>;
  clinicians: <T = Promise<AsyncIterator<ClinicianSubscription>>>(args?: {
    where?: ClinicianWhereInput;
    orderBy?: ClinicianOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group_status: <T = Promise<AsyncIterator<GroupStatusSubscription>>>(args?: {
    where?: GroupStatusWhereInput;
    orderBy?: GroupStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PracticeNullablePromise
  extends Promise<Practice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  enrollment_id: () => Promise<String>;
  enrollment_type: () => Promise<String>;
  first_approval_date: () => Promise<DateTimeOutput>;
  is_enrolled: () => Promise<Boolean>;
  last_approval_date: () => Promise<DateTimeOutput>;
  org_name: () => Promise<String>;
  pecos_id: () => Promise<String>;
  tin: () => Promise<Int>;
  tin_type: () => Promise<String>;
  is_sole_proprietor: () => Promise<Boolean>;
  clinicians: <T = FragmentableArray<Clinician>>(args?: {
    where?: ClinicianWhereInput;
    orderBy?: ClinicianOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  group_status: <T = FragmentableArray<GroupStatus>>(args?: {
    where?: GroupStatusWhereInput;
    orderBy?: GroupStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GroupStatus {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  year: Int;
  run: Int;
  has_aci_hardship?: Boolean;
  has_extreme_hardship?: Boolean;
  has_ia_study?: Boolean;
  is_hospital_based?: Boolean;
  is_low_volume?: Boolean;
}

export interface GroupStatusPromise extends Promise<GroupStatus>, Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  run: () => Promise<Int>;
  has_aci_hardship: () => Promise<Boolean>;
  has_extreme_hardship: () => Promise<Boolean>;
  has_ia_study: () => Promise<Boolean>;
  is_hospital_based: () => Promise<Boolean>;
  is_low_volume: () => Promise<Boolean>;
  practice: <T = PracticePromise>() => T;
}

export interface GroupStatusSubscription
  extends Promise<AsyncIterator<GroupStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  run: () => Promise<AsyncIterator<Int>>;
  has_aci_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_extreme_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_ia_study: () => Promise<AsyncIterator<Boolean>>;
  is_hospital_based: () => Promise<AsyncIterator<Boolean>>;
  is_low_volume: () => Promise<AsyncIterator<Boolean>>;
  practice: <T = PracticeSubscription>() => T;
}

export interface GroupStatusNullablePromise
  extends Promise<GroupStatus | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  run: () => Promise<Int>;
  has_aci_hardship: () => Promise<Boolean>;
  has_extreme_hardship: () => Promise<Boolean>;
  has_ia_study: () => Promise<Boolean>;
  is_hospital_based: () => Promise<Boolean>;
  is_low_volume: () => Promise<Boolean>;
  practice: <T = PracticePromise>() => T;
}

export interface ClinicianConnection {
  pageInfo: PageInfo;
  edges: ClinicianEdge[];
}

export interface ClinicianConnectionPromise
  extends Promise<ClinicianConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClinicianEdge>>() => T;
  aggregate: <T = AggregateClinicianPromise>() => T;
}

export interface ClinicianConnectionSubscription
  extends Promise<AsyncIterator<ClinicianConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClinicianEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClinicianSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ClinicianEdge {
  node: Clinician;
  cursor: String;
}

export interface ClinicianEdgePromise
  extends Promise<ClinicianEdge>,
    Fragmentable {
  node: <T = ClinicianPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClinicianEdgeSubscription
  extends Promise<AsyncIterator<ClinicianEdge>>,
    Fragmentable {
  node: <T = ClinicianSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClinician {
  count: Int;
}

export interface AggregateClinicianPromise
  extends Promise<AggregateClinician>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClinicianSubscription
  extends Promise<AsyncIterator<AggregateClinician>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GroupStatusConnection {
  pageInfo: PageInfo;
  edges: GroupStatusEdge[];
}

export interface GroupStatusConnectionPromise
  extends Promise<GroupStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupStatusEdge>>() => T;
  aggregate: <T = AggregateGroupStatusPromise>() => T;
}

export interface GroupStatusConnectionSubscription
  extends Promise<AsyncIterator<GroupStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupStatusSubscription>() => T;
}

export interface GroupStatusEdge {
  node: GroupStatus;
  cursor: String;
}

export interface GroupStatusEdgePromise
  extends Promise<GroupStatusEdge>,
    Fragmentable {
  node: <T = GroupStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupStatusEdgeSubscription
  extends Promise<AsyncIterator<GroupStatusEdge>>,
    Fragmentable {
  node: <T = GroupStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroupStatus {
  count: Int;
}

export interface AggregateGroupStatusPromise
  extends Promise<AggregateGroupStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupStatusSubscription
  extends Promise<AsyncIterator<AggregateGroupStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IndividualStatus {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  year: Int;
  run: Int;
  has_aci_hardship?: Boolean;
  has_extreme_hardship?: Boolean;
  has_ia_study?: Boolean;
  is_hospital_based?: Boolean;
  is_low_volume?: Boolean;
}

export interface IndividualStatusPromise
  extends Promise<IndividualStatus>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  clinician: <T = ClinicianPromise>() => T;
  practice: <T = PracticePromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  run: () => Promise<Int>;
  has_aci_hardship: () => Promise<Boolean>;
  has_extreme_hardship: () => Promise<Boolean>;
  has_ia_study: () => Promise<Boolean>;
  is_hospital_based: () => Promise<Boolean>;
  is_low_volume: () => Promise<Boolean>;
}

export interface IndividualStatusSubscription
  extends Promise<AsyncIterator<IndividualStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  clinician: <T = ClinicianSubscription>() => T;
  practice: <T = PracticeSubscription>() => T;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  run: () => Promise<AsyncIterator<Int>>;
  has_aci_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_extreme_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_ia_study: () => Promise<AsyncIterator<Boolean>>;
  is_hospital_based: () => Promise<AsyncIterator<Boolean>>;
  is_low_volume: () => Promise<AsyncIterator<Boolean>>;
}

export interface IndividualStatusNullablePromise
  extends Promise<IndividualStatus | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  clinician: <T = ClinicianPromise>() => T;
  practice: <T = PracticePromise>() => T;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  run: () => Promise<Int>;
  has_aci_hardship: () => Promise<Boolean>;
  has_extreme_hardship: () => Promise<Boolean>;
  has_ia_study: () => Promise<Boolean>;
  is_hospital_based: () => Promise<Boolean>;
  is_low_volume: () => Promise<Boolean>;
}

export interface IndividualStatusConnection {
  pageInfo: PageInfo;
  edges: IndividualStatusEdge[];
}

export interface IndividualStatusConnectionPromise
  extends Promise<IndividualStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IndividualStatusEdge>>() => T;
  aggregate: <T = AggregateIndividualStatusPromise>() => T;
}

export interface IndividualStatusConnectionSubscription
  extends Promise<AsyncIterator<IndividualStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IndividualStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIndividualStatusSubscription>() => T;
}

export interface IndividualStatusEdge {
  node: IndividualStatus;
  cursor: String;
}

export interface IndividualStatusEdgePromise
  extends Promise<IndividualStatusEdge>,
    Fragmentable {
  node: <T = IndividualStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IndividualStatusEdgeSubscription
  extends Promise<AsyncIterator<IndividualStatusEdge>>,
    Fragmentable {
  node: <T = IndividualStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIndividualStatus {
  count: Int;
}

export interface AggregateIndividualStatusPromise
  extends Promise<AggregateIndividualStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIndividualStatusSubscription
  extends Promise<AsyncIterator<AggregateIndividualStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PracticeConnection {
  pageInfo: PageInfo;
  edges: PracticeEdge[];
}

export interface PracticeConnectionPromise
  extends Promise<PracticeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PracticeEdge>>() => T;
  aggregate: <T = AggregatePracticePromise>() => T;
}

export interface PracticeConnectionSubscription
  extends Promise<AsyncIterator<PracticeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PracticeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePracticeSubscription>() => T;
}

export interface PracticeEdge {
  node: Practice;
  cursor: String;
}

export interface PracticeEdgePromise
  extends Promise<PracticeEdge>,
    Fragmentable {
  node: <T = PracticePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PracticeEdgeSubscription
  extends Promise<AsyncIterator<PracticeEdge>>,
    Fragmentable {
  node: <T = PracticeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePractice {
  count: Int;
}

export interface AggregatePracticePromise
  extends Promise<AggregatePractice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePracticeSubscription
  extends Promise<AsyncIterator<AggregatePractice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ClinicianSubscriptionPayload {
  mutation: MutationType;
  node: Clinician;
  updatedFields: String[];
  previousValues: ClinicianPreviousValues;
}

export interface ClinicianSubscriptionPayloadPromise
  extends Promise<ClinicianSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClinicianPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClinicianPreviousValuesPromise>() => T;
}

export interface ClinicianSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClinicianSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClinicianSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClinicianPreviousValuesSubscription>() => T;
}

export interface ClinicianPreviousValues {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  birth_state?: String;
  enrollment_id?: String;
  enrollment_type?: String;
  first_approval_date?: DateTimeOutput;
  first_name?: String;
  is_enrolled?: Boolean;
  last_approval_date?: DateTimeOutput;
  last_name?: String;
  middle_name?: String;
  npi: Int;
  pecos_id?: String;
}

export interface ClinicianPreviousValuesPromise
  extends Promise<ClinicianPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  birth_state: () => Promise<String>;
  enrollment_id: () => Promise<String>;
  enrollment_type: () => Promise<String>;
  first_approval_date: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  is_enrolled: () => Promise<Boolean>;
  last_approval_date: () => Promise<DateTimeOutput>;
  last_name: () => Promise<String>;
  middle_name: () => Promise<String>;
  npi: () => Promise<Int>;
  pecos_id: () => Promise<String>;
}

export interface ClinicianPreviousValuesSubscription
  extends Promise<AsyncIterator<ClinicianPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  birth_state: () => Promise<AsyncIterator<String>>;
  enrollment_id: () => Promise<AsyncIterator<String>>;
  enrollment_type: () => Promise<AsyncIterator<String>>;
  first_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  first_name: () => Promise<AsyncIterator<String>>;
  is_enrolled: () => Promise<AsyncIterator<Boolean>>;
  last_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  last_name: () => Promise<AsyncIterator<String>>;
  middle_name: () => Promise<AsyncIterator<String>>;
  npi: () => Promise<AsyncIterator<Int>>;
  pecos_id: () => Promise<AsyncIterator<String>>;
}

export interface GroupStatusSubscriptionPayload {
  mutation: MutationType;
  node: GroupStatus;
  updatedFields: String[];
  previousValues: GroupStatusPreviousValues;
}

export interface GroupStatusSubscriptionPayloadPromise
  extends Promise<GroupStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupStatusPreviousValuesPromise>() => T;
}

export interface GroupStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupStatusPreviousValuesSubscription>() => T;
}

export interface GroupStatusPreviousValues {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  year: Int;
  run: Int;
  has_aci_hardship?: Boolean;
  has_extreme_hardship?: Boolean;
  has_ia_study?: Boolean;
  is_hospital_based?: Boolean;
  is_low_volume?: Boolean;
}

export interface GroupStatusPreviousValuesPromise
  extends Promise<GroupStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  run: () => Promise<Int>;
  has_aci_hardship: () => Promise<Boolean>;
  has_extreme_hardship: () => Promise<Boolean>;
  has_ia_study: () => Promise<Boolean>;
  is_hospital_based: () => Promise<Boolean>;
  is_low_volume: () => Promise<Boolean>;
}

export interface GroupStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  run: () => Promise<AsyncIterator<Int>>;
  has_aci_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_extreme_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_ia_study: () => Promise<AsyncIterator<Boolean>>;
  is_hospital_based: () => Promise<AsyncIterator<Boolean>>;
  is_low_volume: () => Promise<AsyncIterator<Boolean>>;
}

export interface IndividualStatusSubscriptionPayload {
  mutation: MutationType;
  node: IndividualStatus;
  updatedFields: String[];
  previousValues: IndividualStatusPreviousValues;
}

export interface IndividualStatusSubscriptionPayloadPromise
  extends Promise<IndividualStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IndividualStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IndividualStatusPreviousValuesPromise>() => T;
}

export interface IndividualStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IndividualStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IndividualStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IndividualStatusPreviousValuesSubscription>() => T;
}

export interface IndividualStatusPreviousValues {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  year: Int;
  run: Int;
  has_aci_hardship?: Boolean;
  has_extreme_hardship?: Boolean;
  has_ia_study?: Boolean;
  is_hospital_based?: Boolean;
  is_low_volume?: Boolean;
}

export interface IndividualStatusPreviousValuesPromise
  extends Promise<IndividualStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  run: () => Promise<Int>;
  has_aci_hardship: () => Promise<Boolean>;
  has_extreme_hardship: () => Promise<Boolean>;
  has_ia_study: () => Promise<Boolean>;
  is_hospital_based: () => Promise<Boolean>;
  is_low_volume: () => Promise<Boolean>;
}

export interface IndividualStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<IndividualStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  run: () => Promise<AsyncIterator<Int>>;
  has_aci_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_extreme_hardship: () => Promise<AsyncIterator<Boolean>>;
  has_ia_study: () => Promise<AsyncIterator<Boolean>>;
  is_hospital_based: () => Promise<AsyncIterator<Boolean>>;
  is_low_volume: () => Promise<AsyncIterator<Boolean>>;
}

export interface PracticeSubscriptionPayload {
  mutation: MutationType;
  node: Practice;
  updatedFields: String[];
  previousValues: PracticePreviousValues;
}

export interface PracticeSubscriptionPayloadPromise
  extends Promise<PracticeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PracticePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PracticePreviousValuesPromise>() => T;
}

export interface PracticeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PracticeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PracticeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PracticePreviousValuesSubscription>() => T;
}

export interface PracticePreviousValues {
  id: ID_Output;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  enrollment_id?: String;
  enrollment_type?: String;
  first_approval_date?: DateTimeOutput;
  is_enrolled?: Boolean;
  last_approval_date?: DateTimeOutput;
  org_name?: String;
  pecos_id?: String;
  tin: Int;
  tin_type?: String;
  is_sole_proprietor?: Boolean;
}

export interface PracticePreviousValuesPromise
  extends Promise<PracticePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  enrollment_id: () => Promise<String>;
  enrollment_type: () => Promise<String>;
  first_approval_date: () => Promise<DateTimeOutput>;
  is_enrolled: () => Promise<Boolean>;
  last_approval_date: () => Promise<DateTimeOutput>;
  org_name: () => Promise<String>;
  pecos_id: () => Promise<String>;
  tin: () => Promise<Int>;
  tin_type: () => Promise<String>;
  is_sole_proprietor: () => Promise<Boolean>;
}

export interface PracticePreviousValuesSubscription
  extends Promise<AsyncIterator<PracticePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  enrollment_id: () => Promise<AsyncIterator<String>>;
  enrollment_type: () => Promise<AsyncIterator<String>>;
  first_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  is_enrolled: () => Promise<AsyncIterator<Boolean>>;
  last_approval_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  org_name: () => Promise<AsyncIterator<String>>;
  pecos_id: () => Promise<AsyncIterator<String>>;
  tin: () => Promise<AsyncIterator<Int>>;
  tin_type: () => Promise<AsyncIterator<String>>;
  is_sole_proprietor: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Clinician",
    embedded: false
  },
  {
    name: "Practice",
    embedded: false
  },
  {
    name: "IndividualStatus",
    embedded: false
  },
  {
    name: "GroupStatus",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://us1.prisma.sh/public-shellwolf-339/elig-graphql/dev`
});
export const prisma = new Prisma();
